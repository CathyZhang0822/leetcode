import java.util.*;
public class minMalware {
    public static void main(String[] args){
        int[][] graph = {{1,1,0}, {1,1,0}, {0,0,1}};
        int[] initial = {0, 1};
        System.out.println(minMalwareSpread(graph, initial));
    }
    /*
    思路非常strightforward: 对于initial里面的每个元素，都做一遍BFS遍历graph。记录在去除此元素的情况下，还能传染几个。
    返回传染最少的那个
    */
    public static int minMalwareSpread(int[][] graph, int[] initial) {
        Arrays.sort(initial);
        int min = graph.length;
        int res = -1;
        for(int i = 0; i < initial.length; i++){
            int infected = spread(graph, initial, initial[i]);
            if(infected < min){
                res = initial[i];
                min = infected;
            }
        }
        return res;
    }
    // helper function: 传染
    public static int spread(int[][] graph, int[] initial, int target){
        boolean[] visied = new boolean[graph.length];
        int sum = 0;
        for(int i = 0; i < initial.length; i++){
            if(initial[i] == target || visied[initial[i]]) continue;
            Queue<Integer> queue = new LinkedList<>();
            // 关键在于这里的细节：
            // 是add的时候标成visited，而不是remove的时候。不然会重复加进元素进去
            queue.add(initial[i]);
            visied[initial[i]] = true;
            sum ++;

            while(!queue.isEmpty()){
                int k = queue.remove();
                // traverse its neighbors
                for(int j = 0; j < graph[k].length; j++){
                    if(j == target) continue;
                    if(graph[k][j] == 1 && !visied[j]){
                        visied[j] = true;
                        queue.add(j);
                        sum ++;
                    }
                }
            }
        }
        return sum;
    }
}
